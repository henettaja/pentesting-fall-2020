# Week 2 report

<!-- TOC -->

- [Week 2 report](#week-2-report)
- [Owasp10](#owasp10)
    - [Injektio](#injektio)
    - [Haavoittuva tunnistautuminen](#haavoittuva-tunnistautuminen)
    - [Arkaluontoisen datan paljastuminen](#arkaluontoisen-datan-paljastuminen)
    - [XML External Entities XXE](#xml-external-entities-xxe)
    - [Haavoittuva pääsynvalvonta](#haavoittuva-p%C3%A4%C3%A4synvalvonta)
    - [Puutteelliset turvallisuusmääritykset](#puutteelliset-turvallisuusm%C3%A4%C3%A4ritykset)
    - [Cross-Site Scripting XSS](#cross-site-scripting-xss)
    - [Insecure Deserialization](#insecure-deserialization)
    - [Using Components with Known Vulnerabilities](#using-components-with-known-vulnerabilities)
    - [Riittämättömät lokitiedot ja monitorointi](#riitt%C3%A4m%C3%A4tt%C3%B6m%C3%A4t-lokitiedot-ja-monitorointi)
- [WebGoat exercises](#webgoat-exercises)
    - [A2 Broken authentication](#a2-broken-authentication)
        - [Authentication bypasses](#authentication-bypasses)

<!-- /TOC -->

# Owasp10

## 1. Injektio

- Injektiossa johonkin muuttujaan syötetään vihamielistä dataa, joka koodin kääntövaiheessa huijaa järjestelmän ajamaan hyökkääjän muuttujaan syöttämää koodia.

- Haavoittuvuudelle altistuu jos sovellus ei tarkista, filtteröi ja siisti käyttäjien syötteitä, joita käytetään esimerkiksi SQL-tietokanta tai ORM haussa.

- Hyvä tapa suojautua injektiolta on käyttää turvallisesti toteutettua rajapintaa sovelluksen ja tietokannan välissä.

## 2. Haavoittuva tunnistautuminen

- Rikkinäisessä tunnistautumisessa (engl. broken authentication) hyödynnetään aukkoja sovelluksen tunnistautumisjärjestelmässä. Hakkereilla voi olla esimerkiksi listoja valideista käyttäjätunnus ja salasana komboista tai oletus käyttäjätunnuksista ja sen lisäksi voidaan esimerkiksi automaattisesti kirjautua järjestelmään erilaisilla salasanoilla, kunnes oikea löytyy (brute force).

- Järjestelmä on haavoittuvainen edellä mainituilla hyökkäyksille jos se ei osaa tunnistaa ja estää automatisoituja kirjautumisyrityksiä, hyväksyy heikot ja/tai yleiset salasanat, käyttää heikkoja tapoja käyttäjän salasanan palauttamiseen, ei käytä usean vaiheen tunnistautumista, ei säilytä salasanoja vahvan hash-algoritmin suojaamana tai käyttäjäistunnon hallinnointia ei ole toteutettu turvallisesti.

- Hyökkäyksiltä on mahdollista suojautua esimerkiksi usean vaiheen tunnistautumisen käyttöönottamisella ja erilaisten automaattisten kirjautumisyritysten tunnistamisella ja estämisellä.

## 3. Arkaluontoisen datan paljastuminen

- Arkaluontoista dataa voi vuotaa esimerkiksi datan lähettämisen aikana (esimerkiksi man-in-the-middle -hyökkäys), kun data on säilytyksessä palvelimella tai kun data on näkyvissä käyttäjän päätelaitteella. 

- Suojautuakseen data täytyy säilyttää salattuna (ei selkokielisenä tekstinä) aina kun mahdollista (palvelimella, lähetettäessä, käyttäjän päätelaitteella). Salausalgoritmien tulee myös olla turvallisia ja ajantasalla.

- Koskaan ei tule säilyttää arkaluontoista dataa ilman, että se on täysin tarpeellista. Kun se on tarpeellista täytyy se säilyttää turvallisesti ja cryptattuna.

## 4. XML External Entities (XXE)

- Hyökkääjä voi muokata XML muodossa palvelimelle lähetettävää pyyntöä esimerkiksi palauttamaan jotain muuta dataa, kuin tarkoitus. Monet vanhat XML prosessorit  sallivat XXE:en määrittelemisen, joka mahdollistaa datan keräämisen DTD:n (Document type definition) määrityksien ulkopuolelta.

- Mahdollistaa esimerkiksi datan keräämisen, sisäisten järjestelmien skannaamisen sekä palvelunestohyökkäysten suorittamisen.

- Palvelu on erityisen haavoittuvainen jos se hyväksyy XML dataa suoraan erityisesti lähteistä joihin ei voida luottaa. Vaikka DTD olisi määritelty, sen voi ohittaa eikä se näin ollen takaa, ettei järjestelmä olisi haavoittuvainen hyökkäykselle. Ohittamisen estämiseen on kuitenkin olemassa ohjeita, joita kannattaa konsultoida.

## 5. Haavoittuva pääsynvalvonta

- Pääsynvalvonnalla rajoitetaan eri tyyppisten käyttäjien oikeuksia tehdä ja nähdä asioita järjestelmän sisällä.

- Hyvin toteutettu pääsynvalvonta tarkistaa sovelluksen metodien tasolla, että vain tiettynä käyttäjänä (esim vain admin tai user ja ylemmät) tunnistautuneet istunnot voivat suorittaa niille tarkoitettuja toimintoja. Lisäksi täytyy varmistaa, ettei esimerkiksi käyttäjäoikeuksien ylentäminen ole mahdollista muilla kuin tarkoituksenmukaisilla tavoilla.

- Hyväksikäyttö mahdollista estää esimerkiksi kieltämällä kaikki kaikilta käyttäjiltä oletuksena, asettamalla pois päältä palvelimen hakemistorakenteen tulostamisen virheen yhteydessä ja kirjoittamalla testejä, jotka varmistavat metodien käyttöoikeudet automaattisesti.

## 6. Puutteelliset turvallisuusmääritykset

- Puutteelliset turvallisuusmääritykset voivat mahdollistaa hyökkääjille pääsyn salaiseen dataan tai rajattuun toiminnallisuuteen käyttämällä hyväksi tunnettuja haavoittuvuuksia, käyttämättömäksi jääneitä ohjelmiston sivuja tai suojaamattomia tiedostoja sekä hakemistoja.

- Järjestelmä on haavoittuvainen jos esimerkiksi oletus käyttäjänimiä ja salasanoja ei olla muutettu tai poistettu käytöstä, käyttämättä jääneitä toiminnallisuuksia on jäänyt päälle tai virheilmoituksia ei olla muutettu niin, etteivät ne paljasta liikaa järjestelmästä.

- Voi johtaa pahimmillaan koko järjestelmän joutumisen hyökkääjien käsiin.

## 7. Cross-Site Scripting (XSS)

- Mahdollistaa koodin ajamisen käyttäjän selaimessa, jolloin hyökkääjä voi esimerkiksi varastaa käyttäjätunnukset, käyttäjän dataa tai koko käyttäjän istunnon.

- XSS mahdollistaa myös CSRF puolustuksien alasajamisen.

- Mahdollista estää hyödyntämällä frameworkkeja, jotka automaattisesti kiertävät XSS:n käytön, kuten ReactJS tai viimeisin Ruby on Rails.

## 8. Insecure Deserialization

- Tarkoittaa haavoittuvuutta prosessissa, kun dataa muutetaan jostain muodosta takaisin ohjelmointikielen käyttämäksi objektiksi.

- Usein hankala käyttää hyväksi, mutta mikäli toteutus onnistuu, se voi aiheuttaa mittavia vahinkoja.

- Järjestelmä on haavoittuva jos sille hyökkääjä voi syöttää sille haluamaansa dataa deserialisoitavaksi.

## 9. Using Components with Known Vulnerabilities

- Ohjelmistojen kehittäminen niin, ettei pysytä perillä käytetyistä kirjastoista ja muista ulkoisista komponenteista ja niiden komponenttien riippuvuuksista aiheuttaa riskejä jos näissä ulkoisissa komponenteissa on tunnettuja haavoittuvuuksia. 

- Koko ohjelmistopino mukaanlukien kaikki ulkoiset komponentit täytyy olla ajantasalla sekä täytyy olla tietoinen komponenttien käyttämistä riippuvuuksista ja siitä sisältääkö ne tunnettuja haavoittuvuuksia.

- Osa tiedossa olevista haavoittuvuuksista on verrattain pieniä, mutta myös osa isoimmista tietomurroista ikinä on toteutettu valmiiksi tiedossa olevia haavoittuvuuksia hyödyntämällä.

## 10. Riittämättömät lokitiedot ja monitorointi

- Järjestelmien riittämättömät lokitiedot ja monitoroinnin puutteet mahdollistavat hyökkääjille hyökkäyksien toteuttamisen niin, että hyökkäys ilmenee kohteelle vasta myöhemmin ja mahdollisesti ilman kunnollista tietoa hyökkäystavasta.

- Vuonna 2016 tietomurron ilmeneminen kesti keskimäärin 191 päivää.

- Kaikki oleellinen tieto tulee tallentaa lokeihin selkeästi ymmärrettävässä muodossa ja lokitiedot tulee tallentaa useampaan paikkaan ja niihin pääsyä tulee rajoittaa.

# WebGoat exercises

## A2 Broken authentication

### Authentication bypasses

- Materiaalin läpiluettua kokeilin täyttää annettuja security questions kenttiä ja lähettää vastaukset ja tutkia minkälainen HTTP pyyntö siitä lähtee palvelimelle selaimen kehittäjäpaneelin "network" välilehteä hyödyntämällä. Sieltä löytyi parametreistä kohdat, jotka sisältävät vastauskenttiin kirjoitetut tiedot. Materiaalissa kerrottiin, että nuo kentät poistamalla on aiemmin päästy ohi näistä turvakysymyksistä, joten kokeilen tehdä juuri niin käyttämällä ZAPia.

Alkuperäinen pyyntö:

``` secQuestion0=Hello&secQuestion1=Hello&jsEnabled=1&verifyMethod=SEC_QUESTIONS&userId=12309746 ```

Omat yritykset:

``` jsEnabled=1&verifyMethod=SEC_QUESTIONS&userId=12309746 ```

``` secQuestion0=Hello&secQuestion1=Hello&jsEnabled=1&verifyMethod=SEC_QUESTIONS&userId=12345678 ```

``` secQuestion0=true&secQuestion1=true&jsEnabled=1&verifyMethod=SEC_QUESTIONS&userId=12345678 ```

``` secQuestion1=true&jsEnabled=1&verifyMethod=SEC_QUESTIONS&userId=12345678 ```

- Parametrien poistamisesta ei ollut hyötyä ja palvelimen vastaus pyyntöön pysyi samana. Kokeilin myös poistaa kaikki loputkin parametrit, mutta sekään ei tuottanut tulosta vaan palvelin palautti virheen, että se vaatii tiettyjä parametreja. Tässä vaiheessa en keksinyt itse enää muita tapoja ratkaista tehtävää, joten turvauduin googleen ja löysin seuraavan artikkelin, joka käy läpi sisäisesti mitä WebGoat vaatii tehtävän läpäisemiseksi: [WebGoat Authentication Bypass 2](https://pvxs.medium.com/webgoat-authentication-bypass-2-4eeb8e8b502b). WebGoatille täytyy siis antaa parametrit, joiden nimet sisältävät merkkijonon "secQuestion". Näin ollen vaihdoin parametrien nimiksi vain secQuestionA ja secQuestionB ja tehtävä menee läpi. Käytännössä mikä vain menee läpi kunhan parametrien määrä pyynnössä on oikea ja se sisältää parametrin jonka nimessä on secQuestion.

``` secQuestionA=Hello&secQuestionB=Hello&jsEnabled=1&verifyMethod=SEC_QUESTIONS&userId=12309746 ```

- Epäilen, että myös esimerkiksi seuraava toimisi.

``` secQuestionA=Hello&randomParameter=lmao&jsEnabled=1&verifyMethod=SEC_QUESTIONS&userId=12309746 ```
